<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 Warning Mode</title>
    <style>
        /* [1] 기본 설정 */
        body {
            margin: 0; padding: 0;
            background-color: #faf8ef;
            color: #776e65;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        .header {
            width: 300px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        h1 { margin: 0; font-size: 40px; }
        
        /* 사이클 카운트 표시 */
        .cycle-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
            color: #776e65;
        }
        .cycle-count {
            font-size: 24px;
            color: #e94e33; /* 붉은색 강조 */
        }

        .score-box {
            background: #bbada0;
            padding: 5px 15px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            text-align: center;
        }
        .score-box span { display: block; font-size: 12px; color: #eee4da; }

        /* [2] 게임 판 */
        .game-container {
            position: relative;
            width: 300px;
            height: 300px;
            background: #bbada0;
            border-radius: 10px;
            padding: 10px;
            box-sizing: border-box;
            touch-action: none;
        }

        .grid-bg {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            height: 100%;
        }
        .grid-cell {
            background: #cdc1b4;
            border-radius: 5px;
            width: 100%;
            height: 100%;
        }

        /* [3] 레이어 관리 */
        /* 타일 컨테이너 */
        .tile-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            padding: 10px;
            pointer-events: none;
            z-index: 10;
        }

        /* 경고/위험 표시 레이어 (타일 위) */
        .warning-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            padding: 10px;
            pointer-events: none;
            z-index: 20; 
        }

        .tile {
            position: absolute;
            width: 62.5px;
            height: 62.5px;
            transition: transform 0.1s ease-in-out;
            z-index: 10;
        }

        .tile-inner {
            width: 100%;
            height: 100%;
            border-radius: 5px;
            background: #eee4da;
            color: #776e65;
            font-weight: bold;
            font-size: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 삭제 애니메이션 (작아지며 사라짐) */
        .tile-deleted .tile-inner {
            animation: shrink 0.2s forwards;
        }
        @keyframes shrink {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* 등장 애니메이션 */
        .tile-new .tile-inner { animation: pop 0.2s; }
        .tile-merged .tile-inner { animation: pop 0.2s; }
        @keyframes pop {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* [4] 경고 타일 스타일 (SVG Marching Ants) */
        .warning-cursor {
            position: absolute;
            width: 62.5px;
            height: 62.5px;
            z-index: 50; /* 최상단 */
            transition: transform 0.1s ease-in-out; /* 이동 모션 */
        }
        
        /* SVG 선 애니메이션 */
        .marching-ants {
            fill: none;
            stroke: #ff0000;
            stroke-width: 4;
            stroke-dasharray: 8 4; /* 점선 간격 */
            animation: march 1s linear infinite; /* 점선 흐름 애니메이션 */
            vector-effect: non-scaling-stroke;
        }
        
        @keyframes march {
            to {
                stroke-dashoffset: -12; /* 패턴 길이만큼 이동 */
            }
        }

        /* 위험 지역 (노란색 반투명) */
        .danger-zone {
            position: absolute;
            width: 62.5px;
            height: 62.5px;
            background-color: rgba(255, 230, 0, 0.3); /* 노란색 반투명 */
            border: 3px solid #333; /* 검은 테두리 */
            box-sizing: border-box;
            border-radius: 5px;
            z-index: 40; /* 타일(10)보다 위, 커서(50)보다 아래 */
        }

        /* 타일 색상 */
        .val-2 { background: #eee4da; }
        .val-4 { background: #ede0c8; }
        .val-8 { background: #f2b179; color: white; }
        .val-16 { background: #f59563; color: white; }
        .val-32 { background: #f67c5f; color: white; }
        .val-64 { background: #f65e3b; color: white; }
        .val-128 { background: #edcf72; color: white; font-size: 24px; }
        .val-256 { background: #edcc61; color: white; font-size: 24px; }
        .val-512 { background: #edc850; color: white; font-size: 24px; }
        .val-1024 { background: #edc53f; color: white; font-size: 18px; }
        .val-2048 { background: #edc22e; color: white; font-size: 18px; }

        /* [5] 메뉴 UI */
        .overlay {
            display: flex;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(238, 228, 218, 0.9);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 10px;
        }
        .overlay p { font-size: 30px; font-weight: bold; margin-bottom: 20px; color: #776e65; }
        
        button {
            background: #8f7a66;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        input[type=range] {
            width: 200px;
            margin: 20px 0;
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>2048</h1>
        
        <div class="cycle-box">
            <span>WARNING IN</span>
            <div class="cycle-count" id="cycle-display">-</div>
        </div>

        <div class="score-box">
            <span>SCORE</span>
            <div id="score">0</div>
        </div>
    </div>

    <div class="game-container">
        <div class="grid-bg">
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        </div>
        
        <div class="tile-container" id="tile-container"></div>
        
        <div class="warning-container" id="warning-container"></div>

        <div class="overlay" id="start-menu">
            <p>Delete Cycle</p>
            <span id="range-val" style="font-size:24px; font-weight:bold;">5</span>
            <input type="range" id="cycle-input" min="5" max="10" value="5" oninput="document.getElementById('range-val').innerText = this.value">
            <button onclick="startGame()">Start Game</button>
        </div>

        <div class="overlay" id="game-over" style="display:none;">
            <p>Game Over!</p>
            <button onclick="showMenu()">Try Again</button>
        </div>
    </div>

    <button onclick="showMenu()">New Game</button>

    <script>
        const size = 4;
        let cells = [];
        let score = 0;
        let idCounter = 0;

        // 게임 모드 변수
        let cycleLimit = 5;
        let currentStep = 1;
        let warningPos = {x:0, y:0};

        class Tile {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value || 2;
                this.id = idCounter++;
                this.mergedFrom = null;
            }
            savePosition() { this.previousPosition = { x: this.x, y: this.y }; }
            updatePosition(x, y) { this.x = x; this.y = y; }
        }

        function showMenu() {
            document.getElementById('start-menu').style.display = 'flex';
            document.getElementById('game-over').style.display = 'none';
        }

        function startGame() {
            cycleLimit = parseInt(document.getElementById('cycle-input').value);
            currentStep = 1;
            document.getElementById('start-menu').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            initGame();
        }

        function initGame() {
            score = 0;
            currentStep = 1;
            document.getElementById('score').innerText = score;
            document.getElementById('tile-container').innerHTML = '';
            document.getElementById('warning-container').innerHTML = '';

            cells = Array(size).fill(null).map(() => Array(size).fill(null));
            
            // 경고 타일 랜덤 위치
            warningPos = {
                x: Math.floor(Math.random() * size),
                y: Math.floor(Math.random() * size)
            };

            addRandomTile();
            addRandomTile();
            updateView();
        }

        function move(direction) {
            // [1] 경고 타일 위치 업데이트
            const vectors = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}]; // Up, Right, Down, Left
            let vec = vectors[direction];
            
            let nextWx = warningPos.x + vec.x;
            let nextWy = warningPos.y + vec.y;
            
            if (nextWx >= 0 && nextWx < size && nextWy >= 0 && nextWy < size) {
                warningPos.x = nextWx;
                warningPos.y = nextWy;
            }

            // [2] 삭제 턴 체크
            let tileDeleted = false;
            
            if (currentStep >= cycleLimit) {
                if (cells[warningPos.x][warningPos.y]) {
                    cells[warningPos.x][warningPos.y] = null; // 데이터 삭제
                    tileDeleted = true;
                }
                currentStep = 1; // 리셋
            } else {
                currentStep++;
            }

            // [3] 2048 슬라이드
            prepareTiles();
            let moved = false;
            let traversalX = [0, 1, 2, 3];
            let traversalY = [0, 1, 2, 3];

            if (direction === 1) traversalX = traversalX.reverse();
            if (direction === 2) traversalY = traversalY.reverse();

            traversalX.forEach(x => {
                traversalY.forEach(y => {
                    let cell = cells[x][y];
                    if (cell) {
                        let positions = findFarthestPosition({x, y}, vec);
                        let next = getCell(positions.next);

                        if (next && next.value === cell.value && !next.mergedFrom) {
                            let merged = new Tile(positions.next.x, positions.next.y, cell.value * 2);
                            merged.mergedFrom = [cell, next];
                            cells[x][y] = null;
                            cells[positions.next.x][positions.next.y] = merged;
                            cell.updatePosition(positions.next.x, positions.next.y);
                            score += merged.value;
                            moved = true;
                        } else {
                            if (x !== positions.farthest.x || y !== positions.farthest.y) {
                                cells[x][y] = null;
                                cells[positions.farthest.x][positions.farthest.y] = cell;
                                cell.updatePosition(positions.farthest.x, positions.farthest.y);
                                moved = true;
                            }
                        }
                    }
                });
            });

            updateView();
            document.getElementById('score').innerText = score;

            if (moved || tileDeleted) {
                setTimeout(() => {
                    addRandomTile();
                    updateView();
                    if (checkGameOver()) document.getElementById('game-over').style.display = 'flex';
                }, 100);
            }
        }

        function prepareTiles() {
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (cells[x][y]) {
                        cells[x][y].mergedFrom = null;
                        cells[x][y].savePosition();
                    }
                }
            }
        }

        function findFarthestPosition(cell, vector) {
            let previous;
            do {
                previous = cell;
                cell = { x: previous.x + vector.x, y: previous.y + vector.y };
            } while (withinBounds(cell) && !cells[cell.x][cell.y]);
            return { farthest: previous, next: cell };
        }

        function withinBounds(pos) {
            return pos.x >= 0 && pos.x < size && pos.y >= 0 && pos.y < size;
        }

        function getCell(pos) {
            return withinBounds(pos) ? cells[pos.x][pos.y] : null;
        }

        function addRandomTile() {
            let empty = [];
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (!cells[x][y]) empty.push({x, y});
                }
            }
            if (empty.length === 0) return;
            let spot = empty[Math.floor(Math.random() * empty.length)];
            let tile = new Tile(spot.x, spot.y, Math.random() < 0.9 ? 2 : 4);
            tile.isNew = true;
            cells[spot.x][spot.y] = tile;
        }

        function updateView() {
            const tileContainer = document.getElementById('tile-container');
            const warningContainer = document.getElementById('warning-container');
            
            // [UI] 남은 횟수 표시
            let remains = cycleLimit - currentStep + 1;
            document.getElementById('cycle-display').innerText = remains;

            // [Tile] 렌더링
            let tilesToRender = [];
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (cells[x][y]) {
                        tilesToRender.push(cells[x][y]);
                        if (cells[x][y].mergedFrom) tilesToRender.push(...cells[x][y].mergedFrom);
                    }
                }
            }

            tilesToRender.forEach(tile => {
                let el = document.getElementById(`tile-${tile.id}`);
                let px = tile.x * (62.5 + 10);
                let py = tile.y * (62.5 + 10);
                let transform = `translate(${px}px, ${py}px)`;

                if (!el) {
                    el = document.createElement('div');
                    el.id = `tile-${tile.id}`;
                    el.classList.add('tile');
                    el.style.transform = transform;

                    let inner = document.createElement('div');
                    inner.classList.add('tile-inner');
                    inner.classList.add(`val-${tile.value}`);
                    inner.innerText = tile.value;
                    el.appendChild(inner);
                    tileContainer.appendChild(el);

                    if (tile.isNew) {
                        el.classList.add('tile-new');
                        tile.isNew = false;
                    }
                } else {
                    window.requestAnimationFrame(() => {
                        el.style.transform = transform;
                        let inner = el.querySelector('.tile-inner');
                        inner.className = `tile-inner val-${tile.value}`;
                        inner.innerText = tile.value;
                        if (tile.mergedFrom) el.classList.add('tile-merged');
                        else el.classList.remove('tile-merged');
                    });
                }
            });

            let domTiles = document.querySelectorAll('.tile');
            domTiles.forEach(el => {
                let id = parseInt(el.id.split('-')[1]);
                if (!tilesToRender.some(t => t.id === id)) {
                    el.classList.add('tile-deleted'); // 삭제 애니메이션 클래스 추가
                    setTimeout(() => el.remove(), 200); // 애니메이션 후 제거
                }
            });

            // [Warning] 경고 및 위험 표시
            warningContainer.innerHTML = '';

            // 1. 경고 커서 (SVG marching ants)
            let cursor = document.createElement('div');
            cursor.classList.add('warning-cursor');
            let cx = warningPos.x * (62.5 + 10);
            let cy = warningPos.y * (62.5 + 10);
            cursor.style.transform = `translate(${cx}px, ${cy}px)`;

            cursor.innerHTML = `
                <svg width="62.5" height="62.5">
                    <rect x="2" y="2" width="58.5" height="58.5" rx="5" ry="5" class="marching-ants" />
                </svg>
            `;
            warningContainer.appendChild(cursor);

            // 2. 위험 지역 (노란색) 표시 - 삭제 직전 턴에만
            if (remains === 1) { // 1번 남았을 때
                let offsets = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
                let validNeighbors = [];

                // 2-1. 유효한 이웃(상하좌우) 확인
                offsets.forEach(offset => {
                    let dx = warningPos.x + offset.x;
                    let dy = warningPos.y + offset.y;
                    
                    if (dx >= 0 && dx < size && dy >= 0 && dy < size) {
                        validNeighbors.push({x: dx, y: dy});
                    }
                });

                // 2-2. 렌더링 할 구역 결정 (복사)
                let zonesToRender = [...validNeighbors];

                // * 핵심 수정사항: 이웃이 4개 미만(모서리나 구석)이라면 본인(가운데)도 경고 표시에 포함
                if (validNeighbors.length < 4) {
                    zonesToRender.push({x: warningPos.x, y: warningPos.y});
                }

                // 2-3. 렌더링
                zonesToRender.forEach(pos => {
                    let zone = document.createElement('div');
                    zone.classList.add('danger-zone');
                    let zx = pos.x * (62.5 + 10);
                    let zy = pos.y * (62.5 + 10);
                    zone.style.transform = `translate(${zx}px, ${zy}px)`;
                    warningContainer.appendChild(zone);
                });
            }
        }

        function checkGameOver() {
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (!cells[x][y]) return false;
                    let current = cells[x][y];
                    if (x < 3 && cells[x+1][y].value === current.value) return false;
                    if (y < 3 && cells[x][y+1].value === current.value) return false;
                }
            }
            return true;
        }

        document.addEventListener('keydown', (e) => {
            const map = { "ArrowUp": 0, "ArrowRight": 1, "ArrowDown": 2, "ArrowLeft": 3 };
            if (map[e.code] !== undefined) { e.preventDefault(); move(map[e.code]); }
        });

        let startX, startY;
        document.addEventListener('touchstart', (e) => {
            if(e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

        document.addEventListener('touchend', (e) => {
            if (!startX || !startY) return;
            if(e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            let dx = e.changedTouches[0].clientX - startX;
            let dy = e.changedTouches[0].clientY - startY;
            if (Math.abs(dx) < 10 && Math.abs(dy) < 10) return;
            if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 1 : 3);
            else move(dy > 0 ? 2 : 0);
            startX = null; startY = null;
        });

        showMenu();
    </script>
</body>
</html>