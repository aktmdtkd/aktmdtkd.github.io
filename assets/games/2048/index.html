<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 Perfect</title>
    <style>
        /* [1] 기본 설정 */
        body {
            margin: 0;
            padding: 0;
            background-color: #faf8ef;
            color: #776e65;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        .header {
            width: 300px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        h1 { margin: 0; font-size: 40px; }
        
        .score-box {
            background: #bbada0;
            padding: 5px 15px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            text-align: center;
        }
        .score-box span { display: block; font-size: 12px; color: #eee4da; }

        /* [2] 게임 판 */
        .game-container {
            position: relative;
            width: 300px;
            height: 300px;
            background: #bbada0;
            border-radius: 10px;
            padding: 10px;
            box-sizing: border-box;
            touch-action: none;
        }

        .grid-bg {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            height: 100%;
        }
        .grid-cell {
            background: #cdc1b4;
            border-radius: 5px;
            width: 100%;
            height: 100%;
        }

        /* [3] 타일 껍데기 (.tile) - 위치 이동 담당 */
        .tile-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            padding: 10px;
            pointer-events: none;
        }

        .tile {
            position: absolute;
            width: 62.5px;
            height: 62.5px;
            /* 껍데기는 오직 위치 이동(transform)만 transition을 줍니다 */
            transition: transform 0.1s ease-in-out;
            z-index: 10;
        }

        /* [4] 타일 알맹이 (.tile-inner) - 디자인 및 팝 효과 담당 */
        .tile-inner {
            width: 100%;
            height: 100%;
            border-radius: 5px;
            background: #eee4da;
            color: #776e65;
            font-weight: bold;
            font-size: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            /* 알맹이는 팝 효과(Animation)를 담당 */
        }

        /* 등장 애니메이션 (알맹이에 적용) */
        .tile-new .tile-inner {
            animation: pop 0.2s;
        }
        .tile-merged .tile-inner {
            animation: pop 0.2s;
        }

        @keyframes pop {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* 색상 (Inner에 적용) */
        .val-2 { background: #eee4da; }
        .val-4 { background: #ede0c8; }
        .val-8 { background: #f2b179; color: white; }
        .val-16 { background: #f59563; color: white; }
        .val-32 { background: #f67c5f; color: white; }
        .val-64 { background: #f65e3b; color: white; }
        .val-128 { background: #edcf72; color: white; font-size: 24px; }
        .val-256 { background: #edcc61; color: white; font-size: 24px; }
        .val-512 { background: #edc850; color: white; font-size: 24px; }
        .val-1024 { background: #edc53f; color: white; font-size: 18px; }
        .val-2048 { background: #edc22e; color: white; font-size: 18px; }

        /* [5] 기타 UI */
        button {
            background: #8f7a66;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        .overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(238, 228, 218, 0.8);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 10px;
        }
        .overlay p { font-size: 40px; font-weight: bold; margin-bottom: 20px; }
    </style>
</head>
<body>

    <div class="header">
        <h1>2048</h1>
        <div class="score-box">
            <span>SCORE</span>
            <div id="score">0</div>
        </div>
    </div>

    <div class="game-container">
        <div class="grid-bg">
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        </div>
        <div class="tile-container" id="tile-container"></div>
        <div class="overlay" id="game-over">
            <p>Game Over!</p>
            <button onclick="initGame()">Try Again</button>
        </div>
    </div>

    <button onclick="initGame()">New Game</button>

    <script>
        const size = 4;
        let cells = [];
        let score = 0;
        let idCounter = 0;

        class Tile {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value || 2;
                this.id = idCounter++;
                this.mergedFrom = null;
            }
            savePosition() {
                this.previousPosition = { x: this.x, y: this.y };
            }
            updatePosition(x, y) {
                this.x = x;
                this.y = y;
            }
        }

        function initGame() {
            score = 0;
            document.getElementById('score').innerText = score;
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('tile-container').innerHTML = '';
            cells = Array(size).fill(null).map(() => Array(size).fill(null));
            addRandomTile();
            addRandomTile();
            updateView();
        }

        function move(direction) {
            prepareTiles();
            let moved = false;
            let traversalX = [0, 1, 2, 3];
            let traversalY = [0, 1, 2, 3];

            if (direction === 1) traversalX = traversalX.reverse();
            if (direction === 2) traversalY = traversalY.reverse();

            const vectors = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}];
            let vector = vectors[direction];

            traversalX.forEach(x => {
                traversalY.forEach(y => {
                    let cell = cells[x][y];
                    if (cell) {
                        let positions = findFarthestPosition({x, y}, vector);
                        let next = getCell(positions.next);

                        if (next && next.value === cell.value && !next.mergedFrom) {
                            let merged = new Tile(positions.next.x, positions.next.y, cell.value * 2);
                            merged.mergedFrom = [cell, next];
                            cells[x][y] = null;
                            cells[positions.next.x][positions.next.y] = merged;
                            cell.updatePosition(positions.next.x, positions.next.y);
                            score += merged.value;
                            moved = true;
                        } else {
                            if (x !== positions.farthest.x || y !== positions.farthest.y) {
                                cells[x][y] = null;
                                cells[positions.farthest.x][positions.farthest.y] = cell;
                                cell.updatePosition(positions.farthest.x, positions.farthest.y);
                                moved = true;
                            }
                        }
                    }
                });
            });

            if (moved) {
                updateView();
                document.getElementById('score').innerText = score;
                setTimeout(() => {
                    addRandomTile();
                    updateView();
                    if (checkGameOver()) document.getElementById('game-over').style.display = 'flex';
                }, 100);
            }
        }

        function prepareTiles() {
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (cells[x][y]) {
                        cells[x][y].mergedFrom = null;
                        cells[x][y].savePosition();
                    }
                }
            }
        }

        function findFarthestPosition(cell, vector) {
            let previous;
            do {
                previous = cell;
                cell = { x: previous.x + vector.x, y: previous.y + vector.y };
            } while (withinBounds(cell) && !cells[cell.x][cell.y]);
            return { farthest: previous, next: cell };
        }

        function withinBounds(pos) {
            return pos.x >= 0 && pos.x < size && pos.y >= 0 && pos.y < size;
        }

        function getCell(pos) {
            return withinBounds(pos) ? cells[pos.x][pos.y] : null;
        }

        function addRandomTile() {
            let empty = [];
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (!cells[x][y]) empty.push({x, y});
                }
            }
            if (empty.length === 0) return;
            let spot = empty[Math.floor(Math.random() * empty.length)];
            let tile = new Tile(spot.x, spot.y, Math.random() < 0.9 ? 2 : 4);
            tile.isNew = true; // 새로 생김 표시
            cells[spot.x][spot.y] = tile;
        }

        // [핵심] 뷰 업데이트: 껍데기(Outer)와 알맹이(Inner) 분리 렌더링
        function updateView() {
            const container = document.getElementById('tile-container');
            let tilesToRender = [];
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (cells[x][y]) {
                        tilesToRender.push(cells[x][y]);
                        if (cells[x][y].mergedFrom) tilesToRender.push(...cells[x][y].mergedFrom);
                    }
                }
            }

            tilesToRender.forEach(tile => {
                let el = document.getElementById(`tile-${tile.id}`);
                let px = tile.x * (62.5 + 10);
                let py = tile.y * (62.5 + 10);
                let transform = `translate(${px}px, ${py}px)`;

                if (!el) {
                    // 1. 껍데기 (Outer) 생성 - 위치 담당
                    el = document.createElement('div');
                    el.id = `tile-${tile.id}`;
                    el.classList.add('tile');
                    el.style.transform = transform; // 생성 즉시 제자리 배치 (순간이동 방지)

                    // 2. 알맹이 (Inner) 생성 - 모양 담당
                    let inner = document.createElement('div');
                    inner.classList.add('tile-inner');
                    inner.classList.add(`val-${tile.value}`);
                    inner.innerText = tile.value;
                    
                    el.appendChild(inner);
                    container.appendChild(el);

                    if (tile.isNew) {
                        el.classList.add('tile-new'); // 알맹이에 pop 효과 적용됨
                        tile.isNew = false;
                    }
                    if (tile.mergedFrom) {
                        el.classList.add('tile-merged');
                    }
                } else {
                    // 기존 타일 업데이트
                    window.requestAnimationFrame(() => {
                        el.style.transform = transform; // 껍데기 이동 (Transition 적용됨)
                        
                        // 알맹이 업데이트
                        let inner = el.querySelector('.tile-inner');
                        inner.className = `tile-inner val-${tile.value}`;
                        inner.innerText = tile.value;

                        if (tile.mergedFrom) {
                            el.classList.add('tile-merged');
                        } else {
                            el.classList.remove('tile-merged');
                        }
                    });
                }
            });

            // 삭제 로직
            let domTiles = document.querySelectorAll('.tile');
            domTiles.forEach(el => {
                let id = parseInt(el.id.split('-')[1]);
                if (!tilesToRender.some(t => t.id === id)) el.remove();
            });
        }

        function checkGameOver() {
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (!cells[x][y]) return false;
                    let current = cells[x][y];
                    if (x < 3 && cells[x+1][y].value === current.value) return false;
                    if (y < 3 && cells[x][y+1].value === current.value) return false;
                }
            }
            return true;
        }

        document.addEventListener('keydown', (e) => {
            const map = { "ArrowUp": 0, "ArrowRight": 1, "ArrowDown": 2, "ArrowLeft": 3 };
            if (map[e.code] !== undefined) { e.preventDefault(); move(map[e.code]); }
        });

        let startX, startY;
        document.addEventListener('touchstart', (e) => {
            if(e.target.tagName === 'BUTTON') return;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

        document.addEventListener('touchend', (e) => {
            if (!startX || !startY) return;
            if(e.target.tagName === 'BUTTON') return;
            let dx = e.changedTouches[0].clientX - startX;
            let dy = e.changedTouches[0].clientY - startY;
            if (Math.abs(dx) < 10 && Math.abs(dy) < 10) return;
            if (Math.abs(dx) > Math.abs(dy)) move(dx > 0 ? 1 : 3);
            else move(dy > 0 ? 2 : 0);
            startX = null; startY = null;
        });

        initGame();
    </script>
</body>
</html>