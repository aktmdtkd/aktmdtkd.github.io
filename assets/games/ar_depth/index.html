<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Visualizer Fixed</title>
    <style>
        html, body { 
            margin: 0; width: 100%; height: 100%; overflow: hidden; 
            background-color: #1a1a1a !important; 
            font-family: 'Courier New', Courier, monospace; 
            color: #00ff00; 
        }
        #overlay {
            position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 100;
            background: rgba(0, 0, 0, 0.7); padding: 10px; border: 1px solid #444; border-radius: 5px;
        }
        #debug-info {
            position: absolute; bottom: 10px; left: 10px; pointer-events: none; z-index: 100;
            color: yellow; font-size: 12px; text-shadow: 1px 1px 1px black;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="overlay">
        <h3>WebXR Scanner (Fix Visibility)</h3>
        <p>Status: <span id="status">Initializing...</span></p>
        <p>Points: <span id="point-count">0</span> / 30000</p>
    </div>
    <div id="debug-info">Waiting...</div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let container, camera, scene, renderer;
        let controls;
        let hitTestSource = null, hitTestSourceRequested = false;
        let mesh, count = 0, isARMode = false;
        const MAX_POINTS = 30000;
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();
        
        let gridHelper, axesHelper, originMarker;

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        const button = ARButton.createButton(renderer, {
                            requiredFeatures: ['hit-test'],
                            optionalFeatures: ['dom-overlay'],
                            domOverlay: { root: document.body }
                        });
                        document.body.appendChild(button);
                        document.getElementById('status').innerText = "Ready. Press START AR.";
                    } else {
                        document.getElementById('status').innerText = "AR Not Supported";
                    }
                });
            }

            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);

            // ★ 중요 수정 1: 점의 크기를 0.02 (2cm)로 키워서 잘 보이게 함
            const geometry = new THREE.BoxGeometry(0.02, 0.02, 0.02);
            // 조명 영향 덜 받는 BasicMaterial 사용 (잘 보이게)
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            mesh = new THREE.InstancedMesh(geometry, material, MAX_POINTS);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            
            // ★ 중요 수정 2: Frustum Culling 끄기 (무조건 그리기)
            // 이걸 꺼야 3D 뷰어 모드에서 점이 사라지지 않습니다.
            mesh.frustumCulled = false; 
            
            scene.add(mesh);

            // 기준점 (빨간 박스)
            const boxGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const boxMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
            originMarker = new THREE.Mesh(boxGeo, boxMat);
            scene.add(originMarker);

            window.addEventListener('resize', onWindowResize);
        }

        function onSessionStart() {
            isARMode = true;
            count = 0;
            scene.background = null; 
            originMarker.visible = false;
            if(gridHelper) scene.remove(gridHelper); // 그리드 제거
            if(axesHelper) scene.remove(axesHelper);
            document.getElementById('status').innerText = "Scanning... Move phone!";
        }

        function onSessionEnd() {
            isARMode = false;
            renderer.xr.enabled = false;
            
            renderer.setClearAlpha(1.0);
            scene.background = new THREE.Color(0x222222);
            
            document.getElementById('status').innerText = "Viewer Mode";
            originMarker.visible = true;

            // 카메라 리셋
            camera.position.set(0, 2, 3); 
            camera.lookAt(0, 0, 0);
            camera.updateProjectionMatrix();

            if (!controls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.target.set(0, 0, 0);
                controls.update();
            }

            addGrid();
            updateDebugInfo();
        }

        function addGrid() {
            if(gridHelper) scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(10, 20, 0x888888, 0x444444);
            gridHelper.position.set(0, -1.5, 0); // 그리드를 좀 아래로
            scene.add(gridHelper);
            
            if(axesHelper) scene.remove(axesHelper);
            axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function updateDebugInfo() {
            const pos = camera.position;
            document.getElementById('debug-info').innerText = 
                `Cam: ${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}\n` +
                `Points: ${count}`;
        }

        function render(timestamp, frame) {
            if (isARMode && frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0 && count < MAX_POINTS) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        
                        const px = pose.transform.position.x;
                        const py = pose.transform.position.y;
                        const pz = pose.transform.position.z;

                        // 스프레이 (5개씩)
                        for(let i=0; i<5; i++) {
                            if(count >= MAX_POINTS) break;
                            
                            const nx = px + (Math.random()-0.5)*0.15;
                            const ny = py + (Math.random()-0.5)*0.05;
                            const nz = pz + (Math.random()-0.5)*0.15;

                            dummy.position.set(nx, ny, nz);
                            dummy.rotation.set(Math.random(), Math.random(), Math.random());
                            dummy.updateMatrix();
                            mesh.setMatrixAt(count, dummy.matrix);
                            
                            // 높이 색상 (초록색 베이스)
                            // 0m(바닥) 근처는 초록색, 높으면 노란색
                            const h = (ny + 1.0) / 4.0;
                            color.setHSL(0.3 - h*0.2, 1.0, 0.5); 
                            mesh.setColorAt(count, color);
                            
                            count++;
                        }
                        mesh.instanceMatrix.needsUpdate = true;
                        mesh.instanceColor.needsUpdate = true;
                        
                        document.getElementById('point-count').innerText = count;
                    }
                }
                renderer.render(scene, camera);
            } 
            else if (!isARMode) {
                if (controls) controls.update();
                updateDebugInfo();
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>