<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Final Viewer</title>
    <style>
        html, body { 
            margin: 0; width: 100%; height: 100%; overflow: hidden; 
            background-color: #1a1a1a !important; 
            font-family: 'Courier New', Courier, monospace; color: #00ff00; 
        }
        #overlay {
            position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 100;
            background: rgba(0, 0, 0, 0.7); padding: 10px; border: 1px solid #444; border-radius: 5px;
        }
        /* ì§€ë„ ì°¾ê¸° ë²„íŠ¼ (AR ëë‚˜ë©´ ë³´ì„) */
        #center-btn {
            display: none; position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 15px 30px; background: #0088ff; color: white; border: none; border-radius: 30px;
            font-size: 16px; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.5); z-index: 200;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="overlay">
        <h3>WebXR Scanner (Final)</h3>
        <p>Status: <span id="status">Initializing...</span></p>
        <p>Points: <span id="point-count">0</span> / 30000</p>
    </div>
    
    <button id="center-btn" onclick="reCenterMap()">ğŸ“ ì§€ë„ ì°¾ê¸° (Re-Center)</button>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let container, camera, scene, renderer;
        let controls;
        let hitTestSource = null, hitTestSourceRequested = false;
        let mesh, count = 0, isARMode = false;
        const MAX_POINTS = 30000;
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();
        
        let gridHelper, axesHelper;

        // ì „ì—­ í•¨ìˆ˜ë¡œ ë§Œë“¤ê¸° (ë²„íŠ¼ í´ë¦­ìš©)
        window.reCenterMap = function() {
            if (count === 0) {
                alert("ì°íŒ ì ì´ ì—†ìŠµë‹ˆë‹¤!");
                return;
            }
            focusOnPoints();
        };

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        const button = ARButton.createButton(renderer, {
                            requiredFeatures: ['hit-test'],
                            optionalFeatures: ['dom-overlay'],
                            domOverlay: { root: document.body }
                        });
                        document.body.appendChild(button);
                        document.getElementById('status').innerText = "Ready. Press START AR.";
                    } else {
                        document.getElementById('status').innerText = "AR Not Supported";
                    }
                });
            }

            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);

            // ì  ì„¤ì • (ì˜ ë³´ì´ê²Œ 2cm í¬ê¸°, ë°ì€ ì¬ì§ˆ)
            const geometry = new THREE.BoxGeometry(0.02, 0.02, 0.02);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            mesh = new THREE.InstancedMesh(geometry, material, MAX_POINTS);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            mesh.frustumCulled = false; // â˜… ì‹œì•¼ ë°–ì´ì–´ë„ ë¬´ì¡°ê±´ ê·¸ë¦¬ê¸°
            scene.add(mesh);

            window.addEventListener('resize', onWindowResize);
        }

        function onSessionStart() {
            isARMode = true;
            count = 0;
            scene.background = null; 
            document.getElementById('center-btn').style.display = 'none'; // ë²„íŠ¼ ìˆ¨ê¹€
            if(gridHelper) scene.remove(gridHelper);
            document.getElementById('status').innerText = "Scanning... Move phone!";
        }

        function onSessionEnd() {
            isARMode = false;
            renderer.xr.enabled = false;
            
            renderer.setClearAlpha(1.0);
            scene.background = new THREE.Color(0x222222);
            document.getElementById('status').innerText = "Viewer Mode";
            document.getElementById('center-btn').style.display = 'block'; // ë²„íŠ¼ í‘œì‹œ

            // ì»¨íŠ¸ë¡¤ëŸ¬ ì´ˆê¸°í™”
            if (!controls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
            }

            // â˜… ìë™ìœ¼ë¡œ ì¤‘ì‹¬ ì°¾ê¸° ì‹¤í–‰
            focusOnPoints();
            addGrid();
        }

        // â˜… í•µì‹¬ ê¸°ëŠ¥: ì ë“¤ì˜ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•´ì„œ ì¹´ë©”ë¼ ì´ë™
        function focusOnPoints() {
            if (count === 0) return;

            const box = new THREE.Box3();
            const tempMatrix = new THREE.Matrix4();
            const tempPos = new THREE.Vector3();

            // ì  30000ê°œë¥¼ ë‹¤ ëŒë©´ ëŠë¦¬ë‹ˆê¹Œ 100ê°œì”© ê±´ë„ˆë›°ë©° ìƒ˜í”Œë§
            const step = Math.max(1, Math.floor(count / 300));
            
            for (let i = 0; i < count; i += step) {
                mesh.getMatrixAt(i, tempMatrix);
                tempPos.setFromMatrixPosition(tempMatrix);
                box.expandByPoint(tempPos);
            }

            const center = new THREE.Vector3();
            box.getCenter(center); // ì ë“¤ì˜ ì¤‘ì‹¬
            
            const size = new THREE.Vector3();
            box.getSize(size); // ì ë“¤ì˜ ë²”ìœ„ í¬ê¸°
            const maxDim = Math.max(size.x, size.y, size.z);

            // ì¹´ë©”ë¼ ìœ„ì¹˜ ì¬ì„¤ì •: ì¤‘ì‹¬ì—ì„œ ì ë‹¹íˆ ë–¨ì–´ëœ¨ë¦¼
            const distance = maxDim * 2 + 1; // ì¤Œ ì•„ì›ƒ ê±°ë¦¬
            camera.position.set(center.x, center.y + distance, center.z + distance);
            camera.lookAt(center);
            
            camera.updateProjectionMatrix();

            // ì»¨íŠ¸ë¡¤ëŸ¬ íƒ€ê²Ÿë„ ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™
            if (controls) {
                controls.target.copy(center);
                controls.update();
            }
            
            console.log("Focused on:", center);
        }

        function addGrid() {
            if(gridHelper) scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(10, 20, 0x888888, 0x444444);
            gridHelper.position.set(0, -1.5, 0);
            scene.add(gridHelper);
            
            if(axesHelper) scene.remove(axesHelper);
            axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (isARMode && frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0 && count < MAX_POINTS) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        const px = pose.transform.position.x;
                        const py = pose.transform.position.y;
                        const pz = pose.transform.position.z;

                        for(let i=0; i<5; i++) {
                            if(count >= MAX_POINTS) break;
                            const nx = px + (Math.random()-0.5)*0.15;
                            const ny = py + (Math.random()-0.5)*0.05;
                            const nz = pz + (Math.random()-0.5)*0.15;

                            dummy.position.set(nx, ny, nz);
                            dummy.rotation.set(Math.random(), Math.random(), Math.random());
                            dummy.updateMatrix();
                            mesh.setMatrixAt(count, dummy.matrix);
                            
                            const h = (ny + 1.0) / 4.0;
                            color.setHSL(0.3 - h*0.2, 1.0, 0.5); 
                            mesh.setColorAt(count, color);
                            count++;
                        }
                        mesh.instanceMatrix.needsUpdate = true;
                        mesh.instanceColor.needsUpdate = true;
                        document.getElementById('point-count').innerText = count;
                    }
                }
                renderer.render(scene, camera);
            } 
            else if (!isARMode) {
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>