<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR PointCloud Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Courier New', Courier, monospace; color: #00ff00; }
        #overlay {
            position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 100;
            background: rgba(0, 0, 0, 0.7); padding: 10px; border: 1px solid #444; border-radius: 5px;
        }
        h3 { margin: 0 0 5px 0; font-size: 16px; color: white; }
        p { margin: 2px 0; font-size: 12px; color: #aaa; }
        #status { color: #00ff00; font-weight: bold; }
        #error-msg { color: #ff5555; background: rgba(50,0,0,0.8); display: none; padding: 5px; margin-top: 5px;}
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="overlay">
        <h3>WebXR PointCloud Scanner</h3>
        <p>Status: <span id="status">Initializing...</span></p>
        <p>Points: <span id="point-count">0</span></p>
        <div id="error-msg"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let container, camera, scene, renderer;
        let controls;
        let hitTestSource = null, hitTestSourceRequested = false;
        let mesh, count = 0, isARMode = false;
        
        // RViz 느낌을 위한 설정
        const MAX_POINTS = 10000; // 점 개수 대폭 증가
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();
        
        // 시각화 도구들
        let gridHelper, axesHelper;

        try {
            init();
            animate();
        } catch(e) {
            showError(e.message);
        }

        function showError(msg) {
            const el = document.getElementById('error-msg');
            el.style.display = 'block';
            el.innerText = "Error: " + msg;
        }

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            
            // 뷰어용 카메라 (초기값)
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);

            // 조명 (데이터가 잘 보이게 앰비언트 라이트 강화)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(0, 10, 0);
            scene.add(dirLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // === AR 버튼 ===
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        const button = ARButton.createButton(renderer, {
                            requiredFeatures: ['hit-test'],
                            optionalFeatures: ['dom-overlay'],
                            domOverlay: { root: document.body }
                        });
                        document.body.appendChild(button);
                        document.getElementById('status').innerText = "Ready (Click Start AR)";
                    } else {
                        document.getElementById('status').innerText = "AR Not Supported";
                        showError("Device check failed");
                    }
                });
            } else {
                showError("WebXR API missing (HTTPS?)");
            }

            // === 이벤트 리스너 ===
            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);

            // === 점군(Point Cloud) 생성 ===
            // RViz 스타일: 점을 아주 작고 선명하게
            const geometry = new THREE.BoxGeometry(0.01, 0.01, 0.01); // 1cm 큐브
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.5, 
                metalness: 0.5 
            });
            
            // InstancedMesh로 성능 확보
            mesh = new THREE.InstancedMesh(geometry, material, MAX_POINTS);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(mesh);

            window.addEventListener('resize', onWindowResize);
        }

        function onSessionStart() {
            isARMode = true;
            count = 0; // 초기화
            scene.background = null;
            
            // 기존 헬퍼들 제거 (AR 화면 가리지 않게)
            if(gridHelper) scene.remove(gridHelper);
            if(axesHelper) scene.remove(axesHelper);

            document.getElementById('status').innerText = "Scanning... (Move around)";
        }

        function onSessionEnd() {
            isARMode = false;
            renderer.xr.enabled = false;
            
            // 1. 배경을 RViz 스타일 다크 그레이로
            scene.background = new THREE.Color(0x303030);
            document.getElementById('status').innerText = "Visualization Mode";

            // 2. 컨트롤러 활성화
            if (!controls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            }

            // 3. 데이터 중심 찾기 및 시각화 구성
            setupVisualization();
        }

        function setupVisualization() {
            // 점들의 중심과 범위 계산
            if (count === 0) {
                // 데이터 없으면 기본 그리드만
                addGridAndAxes(new THREE.Vector3(0, -1, 0));
                return;
            }

            const box = new THREE.Box3();
            const tempMatrix = new THREE.Matrix4();
            const tempPos = new THREE.Vector3();

            for (let i = 0; i < count; i++) {
                mesh.getMatrixAt(i, tempMatrix);
                tempPos.setFromMatrixPosition(tempMatrix);
                box.expandByPoint(tempPos);
            }

            const center = new THREE.Vector3();
            box.getCenter(center);
            
            // 바닥 높이(min Y) 찾기 -> 그리드를 바닥에 깔기 위해
            const minY = box.min.y;
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.z) + 1; // 그리드 크기 결정

            // 4. RViz 스타일 그리드 & 축 추가
            addGridAndAxes(new THREE.Vector3(center.x, minY, center.z), maxDim);

            // 5. 카메라 뷰 설정 (Isometric View 느낌으로)
            const camDist = Math.max(size.x, size.y, size.z) * 1.5;
            camera.position.set(center.x + camDist, center.y + camDist, center.z + camDist);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
        }

        function addGridAndAxes(position, size = 5) {
            if(gridHelper) scene.remove(gridHelper);
            if(axesHelper) scene.remove(axesHelper);

            // 격자 (Grid)
            // RViz 기본 스타일: 짙은 회색 선
            gridHelper = new THREE.GridHelper(size * 2, 20, 0x888888, 0x444444);
            gridHelper.position.set(position.x, position.y, position.z); // 바닥 높이에 맞춤
            scene.add(gridHelper);

            // 축 (Axes) - RGB
            axesHelper = new THREE.AxesHelper(size / 4); // 그리드보다 작게
            axesHelper.position.set(position.x, position.y, position.z);
            scene.add(axesHelper);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        let lastScanTime = 0;

        function render(timestamp, frame) {
            // === AR Scanning ===
            if (isARMode && frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    // 스캔 속도: 30ms (빠르게)
                    if (hitTestResults.length > 0 && count < MAX_POINTS && timestamp - lastScanTime > 30) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);

                        const px = pose.transform.position.x;
                        const py = pose.transform.position.y;
                        const pz = pose.transform.position.z;

                        dummy.position.set(px, py, pz);
                        dummy.updateMatrix();
                        mesh.setMatrixAt(count, dummy.matrix);

                        // ★ 핵심: 높이에 따른 색상 코딩 (Height Map)
                        // 바닥(낮음) = 파랑/보라, 위(높음) = 빨강/노랑
                        // 대략 -1m ~ 1m 범위를 색상으로 매핑
                        const h = (py + 1.0) / 2.0; // 0~1 사이 값으로 정규화
                        color.setHSL(h, 1.0, 0.5); // 무지개색
                        mesh.setColorAt(count, color);

                        count++;
                        mesh.instanceMatrix.needsUpdate = true;
                        mesh.instanceColor.needsUpdate = true; // 색상 업데이트 필수
                        
                        document.getElementById('point-count').innerText = count;
                        lastScanTime = timestamp;
                    }
                }
                renderer.render(scene, camera);
            } 
            // === 3D Viewer Mode ===
            else if (!isARMode) {
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>