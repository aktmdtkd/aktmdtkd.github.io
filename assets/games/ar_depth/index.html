<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Dense Scanner</title>
    <style>
        /* ★ 핵심 수정 1: html과 body 배경을 강제로 아주 진한 회색으로 고정 */
        html, body { 
            margin: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            background-color: #1a1a1a !important; /* 흰색 방지 강제 적용 */
            font-family: 'Courier New', Courier, monospace; 
            color: #00ff00; 
        }
        #overlay {
            position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 100;
            background: rgba(0, 0, 0, 0.7); padding: 10px; border: 1px solid #444; border-radius: 5px;
        }
        h3 { margin: 0 0 5px 0; font-size: 16px; color: white; }
        p { margin: 2px 0; font-size: 12px; color: #aaa; }
        #status { color: #00ff00; font-weight: bold; }
        #error-msg { color: #ff5555; background: rgba(50,0,0,0.8); display: none; padding: 5px; margin-top: 5px;}
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="overlay">
        <h3>WebXR Dense Scanner</h3>
        <p>Status: <span id="status">Initializing...</span></p>
        <p>Points: <span id="point-count">0</span> / 30000</p>
        <div id="error-msg"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let container, camera, scene, renderer;
        let controls;
        let hitTestSource = null, hitTestSourceRequested = false;
        let mesh, count = 0, isARMode = false;
        
        const MAX_POINTS = 30000; 
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();
        
        let gridHelper, axesHelper;

        try {
            init();
            animate();
        } catch(e) {
            showError(e.message);
        }

        function showError(msg) {
            const el = document.getElementById('error-msg');
            el.style.display = 'block';
            el.innerText = "Error: " + msg;
        }

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            
            // ★ 핵심 수정 2: 초기 배경색을 확실하게 지정
            scene.background = new THREE.Color(0x1a1a1a);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(0, 10, 0);
            scene.add(dirLight);

            // 투명도(alpha) true 유지 (AR 카메라 봐야 하므로)
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        const button = ARButton.createButton(renderer, {
                            requiredFeatures: ['hit-test'],
                            optionalFeatures: ['dom-overlay'],
                            domOverlay: { root: document.body }
                        });
                        document.body.appendChild(button);
                        document.getElementById('status').innerText = "Ready (Click Start AR)";
                    } else {
                        document.getElementById('status').innerText = "AR Not Supported";
                    }
                });
            } else {
                showError("WebXR API missing");
            }

            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);

            const geometry = new THREE.BoxGeometry(0.005, 0.005, 0.005); 
            const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5, metalness: 0.5 });
            
            mesh = new THREE.InstancedMesh(geometry, material, MAX_POINTS);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(mesh);

            window.addEventListener('resize', onWindowResize);
        }

        function onSessionStart() {
            isARMode = true;
            count = 0;
            scene.background = null; // AR 모드에서는 배경 투명 (카메라 보임)
            if(gridHelper) scene.remove(gridHelper);
            if(axesHelper) scene.remove(axesHelper);
            document.getElementById('status').innerText = "Scanning... (Move Phone!)";
        }

        function onSessionEnd() {
            isARMode = false;
            renderer.xr.enabled = false;
            
            // ★ 핵심 수정 3: 종료 즉시 배경색을 다시 칠함
            scene.background = new THREE.Color(0x1a1a1a);
            document.getElementById('status').innerText = "Visualization Mode";

            // ★ 핵심 수정 4: 카메라도 재설정 (AR 카메라는 FOV가 다르므로 복구)
            camera.fov = 60;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.near = 0.01;
            camera.far = 100;
            camera.updateProjectionMatrix();

            if (!controls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
            }
            setupVisualization();
        }

        function setupVisualization() {
            // 점이 하나도 안 찍혔을 경우 대비
            if (count === 0) {
                camera.position.set(0, 1, 2);
                camera.lookAt(0, 0, 0);
                addGridAndAxes(new THREE.Vector3(0, -1, 0));
                return;
            }

            const box = new THREE.Box3();
            const tempMatrix = new THREE.Matrix4();
            const tempPos = new THREE.Vector3();
            
            // 샘플링하여 중심 계산
            const step = Math.max(1, Math.floor(count / 100));
            for (let i = 0; i < count; i += step) {
                mesh.getMatrixAt(i, tempMatrix);
                tempPos.setFromMatrixPosition(tempMatrix);
                box.expandByPoint(tempPos);
            }

            const center = new THREE.Vector3();
            box.getCenter(center);
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.z) + 1;

            addGridAndAxes(new THREE.Vector3(center.x, box.min.y, center.z), maxDim);

            // 카메라 위치 잡기
            const camDist = Math.max(size.x, size.y, size.z) * 1.5;
            camera.position.set(center.x + camDist, center.y + camDist * 0.8, center.z + camDist);
            camera.lookAt(center);
            
            if(controls) {
                controls.target.copy(center);
                controls.update();
            }
        }

        function addGridAndAxes(position, size = 5) {
            if(gridHelper) scene.remove(gridHelper);
            if(axesHelper) scene.remove(axesHelper);
            
            gridHelper = new THREE.GridHelper(size * 2, 20, 0x888888, 0x444444);
            gridHelper.position.set(position.x, position.y, position.z);
            scene.add(gridHelper);
            
            axesHelper = new THREE.AxesHelper(size / 5);
            axesHelper.position.set(position.x, position.y, position.z);
            scene.add(axesHelper);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function randomNoise() {
            return (Math.random() - 0.5) * 0.15; 
        }

        function render(timestamp, frame) {
            if (isARMode && frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0 && count < MAX_POINTS) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);

                        const px = pose.transform.position.x;
                        const py = pose.transform.position.y;
                        const pz = pose.transform.position.z;

                        // 스프레이 (10개씩)
                        const sprayCount = 10; 
                        for(let i=0; i<sprayCount; i++) {
                            if(count >= MAX_POINTS) break;
                            const nx = px + randomNoise();
                            const ny = py + (Math.random() - 0.5) * 0.02;
                            const nz = pz + randomNoise();

                            dummy.position.set(nx, ny, nz);
                            dummy.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
                            dummy.updateMatrix();
                            
                            mesh.setMatrixAt(count, dummy.matrix);

                            // Height Map Color
                            const h = (ny + 1.0) / 2.5; 
                            color.setHSL(h, 1.0, 0.5);
                            mesh.setColorAt(count, color);

                            count++;
                        }
                        mesh.instanceMatrix.needsUpdate = true;
                        mesh.instanceColor.needsUpdate = true;
                        document.getElementById('point-count').innerText = count;
                    }
                }
                renderer.render(scene, camera);
            } 
            else if (!isARMode) {
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>