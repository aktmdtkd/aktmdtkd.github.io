<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Camera Diagnostic Fix</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: monospace; color: white; }
        
        #console-log {
            position: absolute; top: 0; left: 0; width: 100%; height: 200px;
            background: rgba(0,0,0,0.8); pointer-events: none; z-index: 999;
            padding: 10px; box-sizing: border-box; font-size: 13px; color: #ffff00;
            overflow-y: auto; white-space: pre-wrap; border-bottom: 2px solid #555;
        }

        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 800;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        /* Ïä§ÌîºÎÑà */
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid #333; border-top: 4px solid #ff0055; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #loading-text { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        #sub-text { font-size: 14px; color: #aaa; text-align: center; }

        #btn-start {
            padding: 20px 40px; font-size: 20px; font-weight: bold; 
            background: #0088ff; color: white; border: none; border-radius: 10px; cursor: pointer;
            display: none; box-shadow: 0 0 20px rgba(0, 136, 255, 0.5); margin-top: 20px;
        }

        /* ÎπÑÎîîÏò§ Ìà¨Î™Ö Ï≤òÎ¶¨ */
        #videoInput { 
            position: absolute; top: 0; left: 0; width: 1px; height: 1px; 
            opacity: 0; z-index: -1;
        }

        #canvasOutput { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: contain; background: black; z-index: 500;
        }

        #ui-controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 900; display: none;
        }
        #btn-visualize {
            padding: 15px 30px; font-size: 16px; font-weight: bold; 
            background: #ff4757; color: white; border: none; border-radius: 30px; 
        }
        
        #threejs-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 600; 
            display: none; background: #222;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="console-log">ÏãúÏä§ÌÖú Ï†êÍ≤Ä Ï§ë...<br></div>

    <div id="start-overlay">
        <h2 style="margin-bottom: 20px;">ÏãúÏä§ÌÖú ÏßÑÎã® Î™®Îìú</h2>
        
        <div id="loading-area">
            <div class="spinner"></div>
            <div id="loading-text">ÏóîÏßÑ Î∞õÎäî Ï§ë...</div>
            <div id="sub-text">Í≥µÏãù ÏÑúÎ≤Ñ Ïó∞Í≤∞</div>
        </div>

        <button id="btn-start">üì∑ Ïπ¥Î©îÎùº Í∞ïÏ†ú ÏãúÏûë</button>
    </div>

    <video id="videoInput" playsinline webkit-playsinline></video>
    <canvas id="canvasOutput"></canvas>

    <div id="ui-controls">
        <button id="btn-visualize">‚èπ STOP & 3D VIEW</button>
    </div>
    <div id="threejs-container"></div>

    <script>
        function updateLog(msg) {
            const el = document.getElementById('console-log');
            const time = new Date().toLocaleTimeString();
            el.innerHTML += `[${time}] ${msg}<br>`;
            el.scrollTop = el.scrollHeight;
        }

        // --- Ï¥àÍ∏∞ ÌôòÍ≤Ω ÏßÑÎã® ---
        window.onload = function() {
            if (!window.isSecureContext) {
                updateLog("‚ö†Ô∏è Í≤ΩÍ≥†: HTTPSÍ∞Ä ÏïÑÎãôÎãàÎã§ (Not Secure Context).");
                updateLog("Ïπ¥Î©îÎùºÍ∞Ä ÏûëÎèôÌïòÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§.");
                alert("Ï£ºÏùò: HTTPS ÌôòÍ≤ΩÏù¥ ÏïÑÎãôÎãàÎã§. Ïπ¥Î©îÎùºÎäî HTTPS ÎòêÎäî localhostÏóêÏÑúÎßå ÏûëÎèôÌï©ÎãàÎã§.");
            } else {
                updateLog("‚úÖ Î≥¥Ïïà Ïª®ÌÖçÏä§Ìä∏ ÌôïÏù∏Îê® (HTTPS/Localhost).");
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateLog("‚ùå ÏπòÎ™ÖÏ†Å Ïò§Î•ò: Ïπ¥Î©îÎùº APIÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
                updateLog("Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏóêÏÑú Ïπ¥Î©îÎùº Í∂åÌïúÏù¥ Ï∞®Îã®ÎêòÏóàÎäîÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.");
            } else {
                updateLog("‚úÖ Ïπ¥Î©îÎùº API Ï§ÄÎπÑÎê®.");
            }
        };

        // --- OpenCV Î°úÎìú ---
        window.onOpenCvSuccess = function() {
            updateLog("‚úÖ ÏóîÏßÑ Îã§Ïö¥Î°úÎìú ÏôÑÎ£å. Ïª¥ÌååÏùº Ï§ë...");
            document.getElementById('loading-text').innerText = "ÏóîÏßÑ ÏãúÎèô Ï§ë...";
            checkRuntime();
        };

        window.onOpenCvFail = function() {
            updateLog("‚ùå ÏóîÏßÑ Îã§Ïö¥Î°úÎìú Ïã§Ìå®.");
            document.getElementById('loading-text').innerText = "Ïó∞Í≤∞ Ïã§Ìå®";
            document.getElementById('loading-text').style.color = "red";
        };

        function checkRuntime() {
            let checks = 0;
            const timer = setInterval(() => {
                checks++;
                if (typeof cv !== 'undefined' && cv.getBuildInformation) {
                    clearInterval(timer);
                    updateLog("‚úÖ ÏóîÏßÑ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å!");
                    finishLoading();
                } else if (checks > 60) {
                    updateLog("...Ï¥àÍ∏∞Ìôî ÎåÄÍ∏∞ Ï§ë...");
                }
            }, 500);
        }

        function finishLoading() {
            document.getElementById('loading-area').style.display = 'none';
            const btn = document.getElementById('btn-start');
            btn.style.display = 'block';
            
            btn.onclick = function() {
                updateLog("--- [Ïπ¥Î©îÎùº ÏöîÏ≤≠ ÌîÑÎ°úÏÑ∏Ïä§ ÏãúÏûë] ---");
                startCameraPipeline();
            };
        }
    </script>
    
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvSuccess()" onerror="onOpenCvFail()"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let video, canvas, ctx, cap;
        let srcMat, grayMat, oldGrayMat, p0, p1, st, err;
        let isCVRunning = false;
        let finalFeatures = [];
        let scene, camera, renderer, controls, pointCloud;

        window.startCameraPipeline = async function() {
            document.getElementById('start-overlay').style.display = 'none'; 
            video = document.getElementById('videoInput');
            canvas = document.getElementById('canvasOutput');
            
            updateLog("1. Í∂åÌïú ÏöîÏ≤≠ÏùÑ ÏãúÎèÑÌï©ÎãàÎã§...");

            // ‚òÖ ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï: 5Ï¥à ÏïàÏóê ÏùëÎãµ ÏóÜÏúºÎ©¥ Í≤ΩÍ≥†
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error("Timeout: 5Ï¥àÍ∞Ñ ÏùëÎãµ ÏóÜÏùå")), 5000)
            );

            try {
                // Ï†úÏïΩ Ï°∞Í±¥ ÏµúÎåÄÌïú ÎÇÆÍ≤å ÏÑ§Ï†ï (ÌõÑÎ©¥ Ïπ¥Î©îÎùº Ïö∞ÏÑ†, Ïã§Ìå®Ïãú ÏïÑÎ¨¥Í±∞ÎÇò)
                const constraints = { 
                    video: { facingMode: 'environment' }, 
                    audio: false 
                };

                // getUserMediaÏôÄ ÌÉÄÏûÑÏïÑÏõÉ Î†àÏù¥Ïã±
                const stream = await Promise.race([
                    navigator.mediaDevices.getUserMedia(constraints),
                    timeoutPromise
                ]);

                updateLog("2. Ïä§Ìä∏Î¶º ÌöçÎìù ÏÑ±Í≥µ! (" + stream.id + ")");
                video.srcObject = stream;
                
                // ÎπÑÎîîÏò§ Ïû¨ÏÉù ÏãúÎèÑ
                try {
                    await video.play();
                    updateLog("3. ÎπÑÎîîÏò§ Ïû¨ÏÉù ÏãúÏûë.");
                    waitForVideoSize();
                } catch (playErr) {
                    updateLog("‚ùå ÎπÑÎîîÏò§ Ïû¨ÏÉù ÏóêÎü¨: " + playErr);
                }

            } catch (err) {
                updateLog("‚ùå Ïã§Ìå®: " + err.message);
                console.error(err);
                
                if (err.message.includes("Timeout")) {
                    alert("Ïπ¥Î©îÎùº ÏùëÎãµÏù¥ ÏóÜÏäµÎãàÎã§.\n1. Ïù¥ÎØ∏ Í∂åÌïú Í±∞Î∂ÄÎ•º ÎàÑÎ•¥ÏÖ®ÎÇòÏöî?\n2. Îã§Î•∏ Ïï±Ïù¥ Ïπ¥Î©îÎùºÎ•º Ïì∞Í≥† ÏûàÎÇòÏöî?\n3. Î∏åÎùºÏö∞Ï†ÄÎ•º ÏôÑÏ†ÑÌûà ÍªêÎã§ ÏºúÎ≥¥ÏÑ∏Ïöî.");
                } else {
                    alert("Ïπ¥Î©îÎùº Í∂åÌïú Ïò§Î•ò:\n" + err.name + "\nÏÑ§Ï†ïÏóêÏÑú Í∂åÌïúÏùÑ Ï¥àÍ∏∞ÌôîÌï¥Ï£ºÏÑ∏Ïöî.");
                }
                
                // Îã§Ïãú ÏãúÎèÑÌï† Ïàò ÏûàÍ≤å ÌôîÎ©¥ Î≥µÍµ¨
                document.getElementById('start-overlay').style.display = 'flex';
            }
        }

        function waitForVideoSize() {
            const w = video.videoWidth;
            const h = video.videoHeight;
            if (w && h) {
                updateLog(`üìè Ìï¥ÏÉÅÎèÑ Í∞êÏßÄÎê®: ${w}x${h}`);
                canvas.width = w; canvas.height = h;
                document.getElementById('ui-controls').style.display = 'block';
                startOpenCVProcessing(w, h);
            } else {
                updateLog("...Ìï¥ÏÉÅÎèÑ ÎåÄÍ∏∞ Ï§ë...");
                setTimeout(waitForVideoSize, 500);
            }
        }

        function startOpenCVProcessing(width, height) {
            updateLog("Î©îÎ™®Î¶¨ Íµ¨Ï°∞Ï≤¥ ÏÉùÏÑ±...");
            try {
                if(cap) delete cap;
                cap = new cv.VideoCapture(video);
                srcMat = new cv.Mat(height, width, cv.CV_8UC4);
                grayMat = new cv.Mat(height, width, cv.CV_8UC1);
                oldGrayMat = new cv.Mat(height, width, cv.CV_8UC1);
                p0 = new cv.Mat(); p1 = new cv.Mat(); st = new cv.Mat(); err = new cv.Mat();

                cap.read(srcMat);
                // Mat ÏÉùÏÑ± ÌÅ¨Í∏∞ÏôÄ ÎπÑÎîîÏò§ ÌÅ¨Í∏∞ Î∂àÏùºÏπò Ï≤¥ÌÅ¨
                if (srcMat.cols !== width || srcMat.rows !== height) {
                    updateLog("‚ö†Ô∏è ÌÅ¨Í∏∞ Î∂àÏùºÏπò. Ïû¨ÏãúÏûë.");
                    startOpenCVProcessing(width, height); // Ïû¨Í∑Ä Ïû¨ÏãúÎèÑ
                    return;
                }

                cv.cvtColor(srcMat, oldGrayMat, cv.COLOR_RGBA2GRAY);
                
                let none = new cv.Mat();
                cv.goodFeaturesToTrack(oldGrayMat, p0, 150, 0.3, 7, none, 7, false, 0.04);
                none.delete();

                updateLog(`üöÄ V-SLAM ÏóîÏßÑ Ï†ïÏÉÅ Í∞ÄÎèô!`);
                isCVRunning = true;
                requestAnimationFrame(processVideoFrame);
            } catch (e) {
                updateLog("Ï¥àÍ∏∞Ìôî Ï§ë ÏóêÎü¨: " + e);
                setTimeout(() => startOpenCVProcessing(width, height), 1000);
            }
        }

        function processVideoFrame() {
            if (!isCVRunning) return;
            try {
                cap.read(srcMat);
                if (srcMat.cols !== video.videoWidth) {
                    isCVRunning = false; waitForVideoSize(); return;
                }
                
                cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY);

                if (p0.rows > 0) {
                    cv.calcOpticalFlowPyrLK(oldGrayMat, grayMat, p0, p1, st, err);
                    let goodPoints = [];
                    finalFeatures = []; 
                    for (let i = 0; i < p0.rows; i++) {
                        if (st.data[i] === 1) {
                            let newX = p1.data32F[i * 2];
                            let newY = p1.data32F[i * 2 + 1];
                            cv.circle(srcMat, new cv.Point(newX, newY), 5, [0, 255, 0, 255], -1);
                            finalFeatures.push({ u: newX / srcMat.cols, v: newY / srcMat.rows });
                            goodPoints.push(newX, newY);
                        }
                    }
                    cv.imshow('canvasOutput', srcMat);
                    if (goodPoints.length < 30) {
                        let none = new cv.Mat();
                        cv.goodFeaturesToTrack(grayMat, p0, 150, 0.3, 7, none, 7, false, 0.04);
                        none.delete();
                    } else { p1.copyTo(p0); }
                } else {
                     let none = new cv.Mat();
                     cv.goodFeaturesToTrack(grayMat, p0, 150, 0.3, 7, none, 7, false, 0.04);
                     none.delete();
                }
                grayMat.copyTo(oldGrayMat);
                requestAnimationFrame(processVideoFrame);
            } catch (e) {
                // ÏóêÎü¨ Î¨¥Ïãú
                requestAnimationFrame(processVideoFrame);
            }
        }

        document.getElementById('btn-visualize').addEventListener('click', () => {
            updateLog("üõë 3D Î≥ÄÌôò ÏãúÏûë");
            isCVRunning = false;
            if(video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
            document.getElementById('canvasOutput').style.display = 'none'; // 2D Ï∫îÎ≤ÑÏä§ Ïà®ÍπÄ
            document.getElementById('ui-controls').style.display = 'none';
            document.getElementById('threejs-container').style.display = 'block';
            initThreeJS();
        });

        function initThreeJS() {
            const container = document.getElementById('threejs-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 5); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            scene.add(new THREE.GridHelper(10, 20, 0x888888, 0x444444));
            scene.add(new THREE.AxesHelper(2));
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 5); scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            createPointCloud();
            animate3D();
        }

        function createPointCloud() {
            if (finalFeatures.length === 0) { updateLog("‚ö†Ô∏è ÌäπÏßïÏ†ê ÏóÜÏùå"); return; }
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            pointCloud = new THREE.InstancedMesh(geometry, material, finalFeatures.length);
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            const SCALE_X = 5.0; 
            const SCALE_Y = SCALE_X * (window.innerHeight / window.innerWidth); 

            for(let i=0; i<finalFeatures.length; i++) {
                const f = finalFeatures[i];
                const x = (f.u - 0.5) * SCALE_X;
                const y = -(f.v - 0.5) * SCALE_Y;
                const z = (Math.random() - 0.5) * 1.5;
                dummy.position.set(x, z, y); 
                dummy.updateMatrix();
                pointCloud.setMatrixAt(i, dummy.matrix);
                color.setHSL(Math.random(), 1.0, 0.5);
                pointCloud.setColorAt(i, color);
            }
            pointCloud.instanceMatrix.needsUpdate = true;
            pointCloud.instanceColor.needsUpdate = true;
            scene.add(pointCloud);
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            controls.update();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>