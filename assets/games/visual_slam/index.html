<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>V-SLAM Core to 3D Visualizer</title>
    <style>
        body { margin: 0; background: #1a1a1a; overflow: hidden; font-family: monospace; color: #0f0; }
        /* 비디오 및 2D 캔버스 (초기에 보임) */
        #video-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        video { display: none; }
        #canvasOutput { width: 100%; height: 100%; object-fit: cover; }
        
        /* 3D 뷰어 컨테이너 (나중에 보임) */
        #threejs-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; }
        
        /* UI 요소 */
        #info { position: absolute; top: 10px; left: 10px; z-index: 20; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; pointer-events: none; }
        #controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 20; }
        button { padding: 15px 30px; font-size: 16px; font-weight: bold; color: white; background: #d63031; border: none; border-radius: 30px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        button:disabled { background: #555; color: #888; cursor: not-allowed; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
</head>
<body>
    <div id="info">
        Status: <span id="status-text">Loading Engine...</span><br>
        Tracked Features: <span id="feature-count">0</span>
    </div>

    <div id="video-container">
        <video id="videoInput" playsinline webkit-playsinline></video>
        <canvas id="canvasOutput"></canvas>
        <div id="controls">
            <button id="stop-btn" disabled>STOP & VISUALIZE</button>
        </div>
    </div>

    <div id="threejs-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // === 전역 변수 ===
        // OpenCV 관련
        let video, canvas, ctx, cap;
        let srcMat, grayMat, oldGrayMat, p0, p1, st, err, mask;
        let isCVRunning = false;
        let opencvLoaded = false;

        // 데이터 저장소 (추적된 점들의 최종 위치 저장)
        let finalFeatures = []; 

        // Three.js 관련
        let camera3D, scene3D, renderer3D, controls3D;
        let pointCloudMesh;

        // === 1. OpenCV 초기화 및 루프 ===
        window.onOpenCvReady = function() {
            updateStatus("OpenCV Ready. Starting Camera...");
            opencvLoaded = true;
            startCamera();
        };

        async function startCamera() {
            video = document.getElementById('videoInput');
            canvas = document.getElementById('canvasOutput');
            ctx = canvas.getContext('2d');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                video.srcObject = stream;
                video.play();
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    updateStatus("Camera Active. Tracking features...");
                    document.getElementById('stop-btn').disabled = false;
                    startProcessing();
                };
            } catch (err) {
                updateStatus("Camera Error: " + err);
            }
        }

        function startProcessing() {
            if (!opencvLoaded || !video) return;

            cap = new cv.VideoCapture(video);
            srcMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
            grayMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
            oldGrayMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
            p0 = new cv.Mat(); p1 = new cv.Mat(); st = new cv.Mat(); err = new cv.Mat();

            cap.read(srcMat);
            cv.cvtColor(srcMat, oldGrayMat, cv.COLOR_RGBA2GRAY);

            let none = new cv.Mat();
            cv.goodFeaturesToTrack(oldGrayMat, p0, 200, 0.3, 7, none, 7, false, 0.04);
            none.delete();
            mask = new cv.Mat.zeros(video.videoHeight, video.videoWidth, cv.CV_8UC4);

            isCVRunning = true;
            requestAnimationFrame(processVideo);
        }

        function processVideo() {
            if (!isCVRunning) return;
            try {
                if (video.paused || video.ended) return;
                cap.read(srcMat);
                cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY);

                if (p0.rows > 0) {
                    cv.calcOpticalFlowPyrLK(oldGrayMat, grayMat, p0, p1, st, err);
                    
                    let goodPoints = [];
                    finalFeatures = []; // 현재 프레임의 특징점 리스트 초기화

                    for (let i = 0; i < p0.rows; i++) {
                        if (st.data[i] === 1) {
                            let newX = p1.data32F[i * 2];
                            let newY = p1.data32F[i * 2 + 1];
                            
                            // 시각화용 그리기
                            cv.circle(srcMat, new cv.Point(newX, newY), 4, [0, 255, 0, 255], -1);
                            goodPoints.push(newX, newY);
                            
                            // ★ 중요: 나중에 3D로 바꿀 2D 데이터 저장 (정규화하여 저장)
                            // 화면 중앙을 (0,0)으로 하고 -0.5 ~ 0.5 범위로 변환
                            finalFeatures.push({
                                u: (newX / canvas.width) - 0.5,
                                v: (newY / canvas.height) - 0.5
                            });
                        }
                    }
                    cv.imshow('canvasOutput', srcMat);
                    document.getElementById('feature-count').innerText = finalFeatures.length;

                    // 점이 너무 적으면 재추출
                    if (goodPoints.length < 50) {
                         let none = new cv.Mat();
                         cv.goodFeaturesToTrack(grayMat, p0, 200, 0.3, 7, none, 7, false, 0.04);
                         none.delete();
                    } else {
                         p1.copyTo(p0);
                    }
                }
                grayMat.copyTo(oldGrayMat);
                requestAnimationFrame(processVideo);
            } catch (err) { console.error(err); isCVRunning = false;}
        }

        // === 2. 모드 전환 (2D -> 3D) ===
        document.getElementById('stop-btn').addEventListener('click', () => {
            isCVRunning = false;
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }

            updateStatus("Generating 3D Visualization...");
            document.getElementById('video-container').style.display = 'none';
            document.getElementById('threejs-container').style.display = 'block';
            
            initThreeJS();
            create3DPointCloud();
        });

        // === 3. Three.js 3D 시각화 ===
        function initThreeJS() {
            const container = document.getElementById('threejs-container');
            
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0x222222);
            
            // 버드아이뷰를 위해 카메라를 높이 설정
            camera3D = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera3D.position.set(0, 5, 5); // 위에서 아래로
            camera3D.lookAt(0, 0, 0);

            renderer3D = new THREE.WebGLRenderer({ antialias: true });
            renderer3D.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer3D.domElement);

            // 컨트롤 추가
            controls3D = new OrbitControls(camera3D, renderer3D.domElement);
            controls3D.enableDamping = true;
            controls3D.dampingFactor = 0.05;

            // 격자와 축 추가
            const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
            scene3D.add(gridHelper);
            const axesHelper = new THREE.AxesHelper(2);
            scene3D.add(axesHelper);
            
            // 조명
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene3D.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene3D.add(dirLight);

            window.addEventListener('resize', onWindowResize3D);
            animate3D();
        }

        function create3DPointCloud() {
            if (finalFeatures.length === 0) {
                updateStatus("No features tracked available.");
                return;
            }

            const pointCount = finalFeatures.length;
            const geometry = new THREE.IcosahedronGeometry(0.05, 1); // 점 크기
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness: 0.5, roughness: 0.2 });
            pointCloudMesh = new THREE.InstancedMesh(geometry, material, pointCount);

            const dummy = new THREE.Object3D();
            const color = new THREE.Color();

            // ★ 핵심: 2D(u,v) -> 3D(x,y,z) 변환 (가짜 깊이 생성)
            // 가정: 모든 점은 카메라 앞 3미터 거리에 있는 가상의 평면에 있다.
            const FAKE_DEPTH = 3.0; 
            const SCALE_X = 4.0; // 화면 비율에 따른 너비 스케일
            const SCALE_Y = 3.0; // 높이 스케일

            for (let i = 0; i < pointCount; i++) {
                const feature = finalFeatures[i];
                
                // 2D 이미지 좌표를 3D 공간 좌표로 투영
                // u, v는 -0.5 ~ 0.5 범위임
                const x = feature.u * SCALE_X;
                const y = -feature.v * SCALE_Y; // Y축 반전 (이미지 좌표계와 3D 좌표계 차이)
                const z = -FAKE_DEPTH; // 카메라 앞쪽(음수 Z)으로 배치

                dummy.position.set(x, y, z);
                dummy.updateMatrix();
                pointCloudMesh.setMatrixAt(i, dummy.matrix);

                // 중앙에 가까울수록 밝은색 (시각적 효과)
                const dist = Math.sqrt(x*x + y*y);
                color.setHSL(0.3, 1.0, 1.0 - dist*0.2);
                pointCloudMesh.setColorAt(i, color);
            }

            pointCloudMesh.instanceMatrix.needsUpdate = true;
            pointCloudMesh.instanceColor.needsUpdate = true;
            scene3D.add(pointCloudMesh);

            updateStatus(`Visualization Ready (${pointCount} points). Rotate view!`);
        }

        function onWindowResize3D() {
            camera3D.aspect = window.innerWidth / window.innerHeight;
            camera3D.updateProjectionMatrix();
            renderer3D.setSize(window.innerWidth, window.innerHeight);
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (controls3D) controls3D.update();
            renderer3D.render(scene3D, camera3D);
        }

        function updateStatus(msg) {
            document.getElementById('status-text').innerText = msg;
        }

        // 메모리 해제는 복잡하므로 데모에서는 생략 (새로고침 권장)
    </script>
</body>
</html>